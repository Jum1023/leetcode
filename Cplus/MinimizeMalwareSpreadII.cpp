#include<vector>
#include<unordered_set>
using namespace std;

class Solution {
private:
	vector<int> parent;
	vector<int> rank;
	vector<vector<int>> malware;

    void init(int size)
    {
        malware.resize(size);
        rank.resize(size);
        parent.resize(size);
        for(int i=0;i<size;i++)
        {
            parent[i]=i;
            rank[i]=1;
        }
		malware.clear();
    }

	int Find(int x)
	{
		if(x!=parent[x])
			parent[x]=Find(parent[x]);
		return parent[x];
	}

	bool Union(int x,int y)
	{
		int xr=Find(x),yr=Find(y);
		if(xr==yr)
			return false;
		parent[yr]=xr;
		rank[xr]+=rank[yr];
		return true;
	}

	void AddMalware(int x)
	{
		malware[Find(x)].push_back(x);
	}

public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        init(graph.size());
		for(int i=0;i<(int)graph.size()-1;i++)
			for(int j=i+1;j<(int)graph[0].size();j++)
				if(graph[i][j]==1)
					Union(i,j);
		for(int i=(int)initial.size()-1;i>=0;i--)
			AddMalware(initial[i]);
        int res=initial[0],infected=0;
		for(int i=0;i<(int)initial.size();i++)
		{
			int p=Find(initial[i]);
			if(malware[p].size()==1)
			{
				if(rank[p]>infected)
				{
					infected=rank[p];
					res=initial[i];
				}
				else if(rank[p]==infected&&initial[i]<res)
					res=initial[i];
			}
			else
			{
				unordered_set<int> seen;
				seen.insert(initial[i]);
				int count=0;
				for(int j=0;j<(int)malware[p].size();j++)
                    if(initial[i]!=malware[p][j])
					    count+=dfs(graph,seen,malware[p][j]);
				if(rank[p]-count>infected)
				{
					infected=rank[p]-count;
					res=initial[i];
				}
				else if(rank[p]-count==infected&&initial[i]<res)
					res=initial[i];
			}
		}
        return res;
    }

	int dfs(vector<vector<int>>& graph,unordered_set<int>& seen,int current)
	{
		int res=0;
		for(int i=0;i<(int)graph.size();i++)
		{
			if(graph[current][i]==1&&seen.find(i)==seen.end())
			{
				seen.insert(i);
				res+=dfs(graph,seen,i)+1;
			}
		}
		return res;
	}
};